# Bookmarks-Aware MCP Server

A Model Context Protocol (MCP) server that provides full access to Chrome bookmarks -- search, AI-powered enrichment, and organization -- all through natural language.

## Example Usage

### Search bookmarks

> "Find my bookmark about building durable execution engines with SQLite"

The agent calls `get_bookmarks` with query `"durable execution engine SQLite"` and returns:

```json
[
  {
    "url": "https://www.morling.dev/blog/building-durable-execution-engine-with-sqlite/",
    "title": "Building a Durable Execution Engine with SQLite",
    "summary": "A guide to building a durable execution engine using SQLite...",
    "tags": ["sqlite", "distributed-systems", "durable-execution"]
  }
]
```

### Enrich bookmarks with AI metadata

> "Enrich my Python tutorial bookmarks with summaries and tags"

The agent fetches each page via `fetch_page_content`, reads the content, generates a summary and tags, then stores them via `store_bookmark_metadata`. Future searches now include this metadata.

### Reorganize bookmarks

> "Move all my machine learning bookmarks into a new ML folder under bookmark_bar"

The agent calls `create_folder` and `bulk_reorganize` to move bookmarks. Changes appear in Chrome immediately.

## Features

- **Search** -- Keyword search across URLs, titles, summaries, and tags
- **Enrichment** -- Agent-driven: MCP fetches pages, your agent (Claude, GPT, etc.) generates summaries and tags
- **Organization** -- Move, rename, delete bookmarks and create folders directly in Chrome
- **Metadata Storage** -- SQLite database for persistent summaries and tags
- **Cross-platform** -- macOS, Windows, Linux, and Chromium support

## Installation

1. Ensure Python 3.11 or later is installed.

2. Create a virtual environment (recommended):
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install dependencies:
   ```bash
   make setup
   ```

## MCP Client Configuration (Cursor)

Add to your MCP configuration file (typically `~/.cursor/mcp.json`):

```json
{
  "mcpServers": {
    "bookmarks-aware-mcp": {
      "command": "python3",
      "args": ["/absolute/path/to/bookmarks-aware-mcp/src/main.py"]
    }
  }
}
```

Replace `/absolute/path/to/bookmarks-aware-mcp` with the actual path to this project.

## Available Tools

### Search

| Tool | Description |
|------|-------------|
| `get_bookmarks` | Search bookmarks by query, with optional tag filtering. Searches across URL, title, description, summary, and tags. |
| `search_by_tags` | Find bookmarks that match specific tags. |
| `get_bookmark_metadata` | Get stored summary and tags for a specific URL. |

### Enrichment

| Tool | Description |
|------|-------------|
| `fetch_page_content` | Fetch a URL and extract its text content. Returns the content for the agent to analyze. |
| `store_bookmark_metadata` | Store a summary and tags (generated by the agent) for a bookmark. |

The enrichment flow is **agent-driven**: the MCP server handles fetching and storage, while the calling agent does the summarization. No LLM setup required.

### Organization

| Tool | Description |
|------|-------------|
| `move_bookmark` | Move a bookmark to a different folder. |
| `rename_bookmark` | Rename a bookmark's title. |
| `delete_bookmark` | Delete a bookmark. |
| `create_folder` | Create a new bookmark folder. |
| `get_folder_structure` | View the folder hierarchy with bookmark counts. |
| `bulk_reorganize` | Move multiple bookmarks at once. |

All write operations create a `.bak` backup before modifying the bookmarks file.

## Architecture

```
src/
├── main.py            # Entry point
├── server.py          # MCP server, 11 tool definitions
├── bookmarks_store.py # Chrome bookmarks read/write
├── search.py          # Keyword search with metadata support
├── metadata_store.py  # SQLite store (~/.bookmarks-mcp/metadata.db)
├── enrichment.py      # Page fetching + content extraction
└── config.py          # Configuration via environment variables
```

### Enrichment Flow

```
1. Agent calls fetch_page_content(url)
   → MCP fetches page, extracts text via trafilatura, returns content

2. Agent reads content, generates summary + tags using its own model

3. Agent calls store_bookmark_metadata(url, summary, tags)
   → MCP stores metadata in SQLite

4. Future get_bookmarks searches now include the enriched metadata
```

### Key Design Decisions

- **Agent-driven enrichment** -- No LLM in the server. The calling agent does summarization using whatever model it's running on. Zero setup, best quality.
- **Local SQLite metadata** -- Summaries and tags stored at `~/.bookmarks-mcp/metadata.db`. Cross-machine sync tracked as future work.
- **Direct Chrome file writes** -- Bookmarks are modified in-place with automatic backups. Chrome hot-reloads the file.
- **Extensible search** -- `SearchEngine` protocol allows swapping in semantic search later.

For full decision records with tradeoffs and alternatives, see [decisions.md](.cursor/skills/project-spec/decisions.md).

## Configuration

The server reads Chrome bookmarks from the default location:
- **macOS**: `~/Library/Application Support/Google/Chrome/Default/Bookmarks`
- **Windows**: `%LOCALAPPDATA%\Google\Chrome\User Data\Default\Bookmarks`
- **Linux**: `~/.config/google-chrome/Default/Bookmarks`

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `BOOKMARKS_RATE_LIMIT` | `2.0` | Requests per second for page fetching |
| `BOOKMARKS_MAX_CONCURRENT` | `5` | Max concurrent page fetches |
| `BOOKMARKS_MAX_CONTENT` | `50000` | Max chars to extract from a page |
| `BOOKMARKS_TIMEOUT` | `30.0` | HTTP request timeout (seconds) |
| `BOOKMARKS_METADATA_DB` | `~/.bookmarks-mcp/metadata.db` | Custom metadata DB path |

## Future Enhancements

For planned features and project progress, see the [project board](.cursor/skills/project-board/board.md).

## Error Handling

- Missing bookmarks file: Returns empty results with a warning
- Malformed JSON: Logs error, returns empty results
- Failed page fetches: Returns error message, does not crash
- Write failures: Backup preserved, error reported
